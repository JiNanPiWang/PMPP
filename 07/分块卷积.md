## 我有个问题，srcCol，srcRow为什么不能就是我们当前的blockIdx.x * blockDim.x + threadIdx.x，blockIdx.y * blockDim.y + threadIdx.y，我们当前不是$16 \times 16$ 个线程全员出动。每个线程负责从 Global Memory 搬运 1个 像素到 Shared Memory吗


没问题，我们抛开复杂的公式，直接用一个**超级简单的 1D 数组**来模拟一下，你就立刻明白了。

假设我们只有 **1 行** 像素。

### 📊 设定场景

1.  **滤波器半径 ($r$) = 1**:
    * 这意味着：要算像素 `X`，必须知道 `[X-1, X, X+1]` 这三个数。
    * **算 1 个输出，消耗 3 个输入。**

2.  **线程块大小 (Block Size) = 4**:
    * 你的策略是：每个 Block 开 4 个线程，搬运 4 个数据进 Shared Memory。
    * **Input Tile = 4**。

3.  **有效输出大小 (Output Tile)**:
    * 因为两头各有一个光环（Halo）不能算，所以中间能算出来的只有：
    * $4 - 1 - 1 = 2$ 个。
    * **Output Tile = 2**。

---

### ❌ 假如按你的想法 (错误示范)

你认为公式应该是：`src = blockIdx * blockDim + threadIdx`
也就是：**Block 0 搬 `0~3`，Block 1 搬 `4~7`...**

我们来看看会发生什么灾难：

#### **Block 0 (负责搬运 Input 0, 1, 2, 3)**
Shared Memory 里有了: `[0, 1, 2, 3]`
* 线程 1 (中间) 拿 `0,1,2` -> 算出 **Output[1]**。
* 线程 2 (中间) 拿 `1,2,3` -> 算出 **Output[2]**。
* (线程 0 和 3 是边缘，没法算，因为缺左边或右边的数)。
* **Block 0 产出：Output 1, 2**。

#### **Block 1 (紧接着搬运 Input 4, 5, 6, 7)**
Shared Memory 里有了: `[4, 5, 6, 7]`
* 线程 1 (中间) 拿 `4,5,6` -> 算出 **Output[5]**。
* 线程 2 (中间) 拿 `5,6,7` -> 算出 **Output[6]**。
* **Block 1 产出：Output 5, 6**。

#### **💀 灾难现场：Output 3 和 4 去哪了？**

* **Output 3** 需要输入：`[2, 3, 4]`。
    * Block 0 有 `2, 3`，但没有 `4`。❌ 算不出来。
    * Block 1 有 `4`，但没有 `2, 3`。❌ 也算不出来。
* **Output 4** 需要输入：`[3, 4, 5]`。
    * 同理，两个 Block 谁的数据都不全。

**结论：** 如果按照你的公式，Block 之间完全不重叠，那么**交界处**的数据就没人能算了，你的输出图像会变成：
`[空, 1, 2, 空, 空, 5, 6, 空...]` ——全是黑洞。

---

### ✅ 正确的做法 (重叠策略)

为了把 **Output 3 和 4** 补上，Block 1 必须**“往回退”**一点，去把 Block 0 用过的尾巴再读一遍。

我们希望 Block 0 产出 `1, 2`，那么 **Block 1 就必须紧接着产出 `3, 4`**。



#### **Block 1 的正确行为**
它负责算出 **Output 3, 4**。
为了算 Output 3 (需要 `2,3,4`) 和 Output 4 (需要 `3,4,5`)：
它必须加载输入：**`2, 3, 4, 5`**。

让我们套用书上的公式：
`src = blockIdx * OUT_TILE_DIM + tx - r`
这里 `OUT_TILE_DIM` = 2。

**Block 1 (blockIdx = 1):**
* 基准点 = `1 * 2 = 2` (紧接在 Block 0 的产出之后)。
* 再往回退半径 `r=1`。
* **起始读取点 = 2 - 1 = 1。**

线程搬运情况：
* tx 0 -> 读 Input 1
* tx 1 -> 读 Input 2
* tx 2 -> 读 Input 3
* tx 3 -> 读 Input 4
*(注：这里为了简化模型，假设我们对齐稍微有点差异，但核心思想是：**Block 1 读取的数据必须包含 Block 0 的尾部数据**)*

### 🔑 总结

* **你的公式 (`blockIdx * 16`)：** 像切蛋糕一样，切得整整齐齐。
    * **后果：** 蛋糕中间的奶油（边缘像素）切丢了。
* **书上的公式 (`blockIdx * 12 ...`)：** 像铺瓦片一样，**第二块瓦片必须压在第一块瓦片的边缘上**。
    * **后果：** 虽然浪费了一点材料（重叠读取），但屋顶（输出图像）是严丝合缝的，没有漏水。

这就是为什么必须用 **`OUT_TILE_DIM` (12)** 作为步长，而不是 **Block Dim (16)**。我们要保证输出是连贯的，就必须强迫输入是重叠的。